# t32调试
## 使用t32扫描任意又jtag接口的板子（arm-coresight）
1. `SYStem.CPU ZYNQ-ULTRASCALE+-APU` ;设置jtag CPU类型，这里必须要知道芯片的类型，
      如SYStem.CPU CORTEXA53,ZYNQ-ULTRASCALE+-APU也是a53但可能romtable位置不在标准0
      上，所以无法通过CORTEXA53来获取正确的romtable值，同理也无法通过`SYStem.DETECT SHOWChain`
      获取ir,dr TAP宽度.该范例中会错误获取dap IDCODE为非法值0
2. `SYStem.DETECT DAP` ;扫描romtable,可从中获取编写tartup.cmm t32调试脚本的多个core
    的`COREBASE``CTIBASE``SYStem.CONFIG DEBUGACCESSPORT  1.` `SYStem.CONFIG AXIACCESSPORT 0.`
    `SYStem.CONFIG JTAGACCESSPORT 2.`在DETECH DAP窗口中鼠标右键`copy masked commands to clipboard`即可
3. `SYStem.DETECT SHOWChain` ;查看 irpre irpost drpre drpost,鼠标双击要选择的dap即会自动配置ir dr宽度
4. 根据 2,3得到COREBASE CTIBASE和SYStem.CONFIG 参数，即生成如下最简单的t32连接脚本

```xilinx.cmm
area.reset
area.view
SYStem.RESet

SYStem.CPU ZYNQ-ULTRASCALE+-APU

SYStem.CONFIG.CORENUMBER 4 ;决定CORE.ASSIGN的个数？

core.number 4 ;实际使用的core number大小
CORE.ASSIGN 1. 2. 3. 4. 
SYStem.CONFIG.CORE 1. 1.

SYStem.CONFIG COREBASE DAP:0x80410000 DAP:0x80510000 DAP:0x80610000 DAP:0x80710000
SYStem.CONFIG CTIBASE  DAP:0x80420000 DAP:0x80520000 DAP:0x80620000 DAP:0x80720000

SYStem.CONFIG DEBUGACCESSPORT 1.
SYStem.CONFIG AXIACCESSPORT  0.
SYStem.CONFIG JTAGACCESSPORT 2.

SyStem.UP
```
## t32 linux调试

### ref
+ 可以从trace软件的help中搜索到该文档，该文档详细描述了debug linux的T32配置和范例`https://www2.lauterbach.com/pdf/training_rtos_linux.pdf`
 
### 加载symbol和识别源码路径
+ ref 
```training_rtos_linux.pdf
   └--Setting up a Script for Linux-Aware debugging
     └--Linux Setup-Steps and -Commands
        └--Load Kernel Symbols
The kernel debug information is included in the file vmlinux. This file has to be compiled with debugging
information enabled as already explained. You can load the kernel debug symbols using the following
command:       
Data.LOAD.Elf vmlinux /NoCODE ; load only kernel debug symbols
The option /NOCODE should be used to only load the symbols without kernel code.    
...
Using the button Store..., the resulting sYmbol.SourcePATH.Translate command can be saved in a
PRACTICE script
sYmbol.SourcePATH.Translate "\home\kjmal\kernel\" "C:\Training\Linux\"
``` 
+ 实际范例如下
```
Data.LOAD.Elf X:\linux\vmlinux /NoCODE
sYmbol.SourcePATH.Translate "\home\tomhou\linux\" "x:\linux"
```
+ 如何得到本地编译路径
  如何得到`\home\tomhou\linux\`,加载符号后 list显示b::list界面后鼠标右键,Program Address->Resolve Path后可以看到当前的编译路径，得到编译路径后就可以使用`sYmbol.SourcePATH.Translate` 进行相对路径转换，转换完后就能在debug时正确打开源文件

### 使用trace32提供的linux菜单命令

+ 必须使用t32安装目录的linux菜单配置，以确保该菜单和t32版本匹配
```
TASK.CONFIG ~~/demo/arm64/kernel/linux/awareness/linux.t32
MENU.ReProgram ~~/demo/arm64/kernel/linux/awareness/linux.men
```
+ 可在trace32软件菜单中查看所有进程，dmesg，包括内核perf 函数占用百分比，可用来优化内核
```trace32 menu
查看dmesg
Linux
└--Display Kernel log
查看perf,perf用来进行性能调优？类似于linux的sudo perf top -p pid？
Perf
└--Perf List
查看其它参考Linux,Perf菜单
```

## beramental connect 脚本如下:  
```connect.cmm
SYStem.JtagClock 30mhz

;Depends on how you log in to the shared file, right

&WINDOWS_PATH="Z:\data\test_proj"
&BUILD_PATH="/home/user/data/test_proj"

sYmbol.SourcePATH.SetRecurseDir  "&(WINDOWS_PATH)"
sYmbol.SourcePATH.Translate  "&(BUILD_PATH)"  "&(WINDOWS_PATH)"
data.load.elf  "&(WINDOWS_PATH)\bin\case.elf"  /path  "&(WINDOWS_PATH)" /nocode
list
```
+ 使用代码窗口的mode展开汇编

## 查看exception原因
## Cortex-A55
+ 路径Cortex-A55 --> System Control and Configuration --> EC (Breakpoint/lower level)/(data abort). 当同步异常的时候首先查看最后的func/指令地址 :elr寄存器/x30，

## 异常后排除方法
* 如果同步异常后，elr寄存器会保存最后返回的指令地址，如下描述，来自于手册`DDI0487E_a_armv8_arm.pdf` 不通的el对应不同的ELR, 下次可以打断点到该位置进行step指令运行，查看具体原因，也可以使用trace功能，但会比较麻烦，目前只在ds5上进行过trace功能的测试
```
《DDI0487E_a_armv8_arm.pdf》
Exception Link Registers (ELRs)
Exception Link Registers hold preferred exception return addresses.
Whenever the PE takes an exception, the preferred return address is saved in the ELR at the Exception level the
exception is taken to. For example, whenever the PE takes an exception to EL1, the preferred return address is saved
in ELR_EL1.
On an exception return, the PC is restored to the address stored in the ELR. For example, on returning from EL1,
the PC is restored to the address stored in ELR_EL1.
AArch64 state provides an ELR for each Exception level exceptions can be taken to. The ELRs that AArch64 state
provides are:
• ELR_EL1, for exceptions taken to EL1.
• If EL2 is implemented, ELR_EL2, for exceptions taken to EL2.
• If EL3 is implemented, ELR_EL3, for exceptions taken to EL3.
On taking an exception from AArch32 state to AArch64 state, bits[63:32] of the ELR are set to zero.
```

## 如何使用trace功能 
